---
title: "One Piece Regional Simulation"
format: html
editor: visual
---

# **Abstract**

This document outlines a Monte Carlo simulation designed to model and analyze the competitive metagame of the One Piece Card Game. By leveraging empirical matchup win-rate data and leader play-rate statistics, the model simulates a large number of multi-stage tournaments to determine the probabilistic performance of various archetypes. The objective is to produce robust metrics, including Swiss round win rates, Top 32 playoff conversion rates, and overall tournament win rates, thereby offering insights into the metagame's structure beyond the scope of single-event results.

### **1. Methodology**

The simulation is constructed in the R programming language, utilizing several packages from the Tidyverse ecosystem for data manipulation and visualization. The methodology is divided into two phases: data preparation and simulation design.

#### **1.1 Data Preparation**

The model is predicated on two primary datasets:

1.  **Matchup Win Rates**: Comprehensive matrices detailing the win probability for each leader archetype against every other. These matrices are further refined to distinguish between outcomes where a player goes first versus second, a critical variable in the game's dynamics.

2.  **Leader Play Rates**: The observed frequency of each leader within the competitive field. This data is used to construct a representative player population for each simulated tournament.

The following R code block handles the loading, cleaning, and preparation of this foundational data.

```{r setup}
#| root.dir: "C:/Users/march/Desktop/Projekte/one_piece_meta/pics_data"
#| include: false
# Load our toolkit of R packages
library(dplyr)
library(tidyr)
library(ggplot2)
library(ggrepel)
library(forcats)

set.seed(123)


```


```{r}
# Load the raw matchup data from our CSV files
df_first_raw <- read.csv("pics_data/winrates_first.csv", stringsAsFactors = FALSE, check.names = FALSE)
df_second_raw <- read.csv("pics_data/winrates_second.csv", stringsAsFactors = FALSE, check.names = FALSE)

# Sync the leader names between the two files to prevent errors
df_second_raw[, 1] <- df_first_raw[, 1]

prepare_matrix <- function(df_raw, player_names) {
  # Assign column names from the list of leaders
  colnames(df_raw)[-1] <- player_names
  
  # Select the win rate columns (all but the first)
  win_rate_cols <- df_raw[, -1]
  
  # Clean and convert the win rate columns to numeric
  # This step handles potential non-numeric characters like '%' or spaces
  win_rate_matrix <- as.matrix(sapply(win_rate_cols, function(x) as.numeric(gsub("[^0-9.]", "", x))))
  
  # Assign row and column names
  rownames(win_rate_matrix) <- player_names
  colnames(win_rate_matrix) <- player_names
  
  # Convert percentages to decimals
  win_rate_matrix <- win_rate_matrix / 100.0
  
  return(win_rate_matrix)
}

# Get the list of leaders and create our final win-rate matrices
leaders <- df_first_raw[, 1]
win_matrix_first <- prepare_matrix(df_first_raw, leaders)
win_matrix_second <- prepare_matrix(df_second_raw, leaders)

# Define the initial popularity (play rate) of each leader
playrate_df <- data.frame(
  Leader = leaders,
  Playrate = c(14.5,7.8,7.2,7.1,7.1,6.7,5.6,5.5,5,3.1,2.9,2.6,2.5,1.9)
)

# Normalize playrates to ensure they sum to 100% for the simulation
initial_probabilities <- playrate_df$Playrate / sum(playrate_df$Playrate)
```

## **1.2 Simulation Design**

The simulation models a series of large-scale tournaments. Each event consists of two stages: a multi-round Swiss stage followed by a single-elimination playoff.

-   **Parameters**: The simulation consists of 1,000 tournaments, each with 1,024 competing agents. The number of Swiss rounds is 10, determined by `log2(1024)`.

-   **Swiss Stage**: Agents are paired against opponents with identical or similar win-loss records. Match outcomes are determined probabilistically based on the matchup-specific win rates from the prepared matrices.

-   **Playoff Stage**: The top 32 agents from the Swiss stage advance to a single-elimination, best-of-three playoff bracket. Seeding is based on Swiss round performance. For each best-of-three match, the higher-seeded agent chooses to play first or second in the first game, making the statistically optimal decision based on the matchup. In subsequent games within the same match, the loser of the previous game is granted this choice.

```{r}
# --- Simulation Parameters ---
N_AGENTS <- 1024
N_TOURNAMENTS <- 1000
N_ROUNDS <- log2(N_AGENTS) # 10 rounds

# --- Data structures to store results ---
all_tournament_data <- data.frame()
tournament_winners <- c()

# --- Helper Function: Simulate one Best-of-3 match ---
play_bo3_match <- function(player_H, player_L, win_matrix_first, win_matrix_second) {
  wins_H <- 0; wins_L <- 0
  chooser <- "H" 

  while (wins_H < 2 && wins_L < 2) {
    deck_H <- player_H$Deck; deck_L <- player_L$Deck
    
    if (chooser == "H") {
      wr_first <- win_matrix_first[deck_H, deck_L]
      wr_second <- win_matrix_second[deck_H, deck_L]
      game_wr <- if (wr_first >= wr_second) wr_first else wr_second
    } else { 
      wr_first <- win_matrix_first[deck_L, deck_H]
      wr_second <- win_matrix_second[deck_L, deck_H]
      game_wr <- if (wr_first >= wr_second) 1 - wr_first else 1 - wr_second
    }
    
    if (runif(1) <= game_wr) {
      wins_H <- wins_H + 1; chooser <- "L"
    } else {
      wins_L <- wins_L + 1; chooser <- "H"
    }
  }
  return(if (wins_H == 2) player_H else player_L)
}
```

### **2. Simulation Execution**

The main simulation loop iterates through the specified number of tournaments, executing the Swiss and playoff stages for each. Agent data and final tournament winners are aggregated for subsequent analysis.

```{r}
# --- Main Tournament Loop ---
for (tourney_i in 1:N_TOURNAMENTS) {
  
  agents <- data.frame(
    Deck = sample(leaders, N_AGENTS, replace = TRUE, prob = initial_probabilities),
    Wins = 0, Losses = 0
  )
  
  for (round_j in 1:N_ROUNDS) {
    agents <- agents[order(agents$Wins, decreasing = TRUE, sample(N_AGENTS)), ]
    for (match_k in 1:(N_AGENTS / 2)) {
      p1_idx <- (match_k * 2) - 1; p2_idx <- match_k * 2
      deck1 <- agents$Deck[p1_idx]; deck2 <- agents$Deck[p2_idx]
      
      win_rate_p1 <- if (runif(1) > 0.5) win_matrix_first[deck1, deck2] else win_matrix_second[deck1, deck2]
      
      if (runif(1) <= win_rate_p1) {
        agents$Wins[p1_idx] <- agents$Wins[p1_idx] + 1
        agents$Losses[p2_idx] <- agents$Losses[p2_idx] + 1
      } else {
        agents$Losses[p1_idx] <- agents$Losses[p1_idx] + 1
        agents$Wins[p2_idx] <- agents$Wins[p2_idx] + 1
      }
    }
  }

  agents$Tournament_ID <- tourney_i
  all_tournament_data <- rbind(all_tournament_data, agents)
  
  top_32_players <- agents %>%
    slice_max(order_by = Wins, n = 32, with_ties = FALSE) %>%
    mutate(Seed = 1:32)

  playoff_round <- top_32_players
  while (nrow(playoff_round) > 1) {
    winners <- list()
    num_matches <- nrow(playoff_round) / 2
    for (i in 1:num_matches) {
      player_H <- playoff_round[i, ]; player_L <- playoff_round[nrow(playoff_round) - i + 1, ]
      winners[[i]] <- play_bo3_match(player_H, player_L, win_matrix_first, win_matrix_second)
    }
    playoff_round <- do.call(rbind, winners)
  }
  
  tournament_winners <- c(tournament_winners, playoff_round$Deck)
  if (tourney_i %% 200 == 0) cat(paste("...Completed tournament", tourney_i, "/", N_TOURNAMENTS, "\n"))
}
```

## **3. Results and Analysis**

Upon completion of the simulations, the aggregated data is processed to derive key performance indicators for each leader archetype. The primary metrics are:

-   **Swiss Win Rate**: The aggregate game win percentage across all Swiss rounds.

-   **Top 32 Conversion Rate**: The frequency with which an archetype qualifies for the playoff stage, normalized by its total representation. This metric evaluates consistency and performance under pressure.

-   **Tournament Win Rate**: The percentage of total simulated tournaments won by an archetype, representing the ultimate measure of success.

```{r}
# --- Data Analysis ---
swiss_performance <- all_tournament_data %>%
  group_by(Deck) %>%
  summarise(Swiss_Win_Rate = sum(Wins) / (sum(Wins) + sum(Losses)))

top_32_finishers <- all_tournament_data %>%
  group_by(Tournament_ID) %>%
  slice_max(order_by = Wins, n = 32, with_ties = FALSE) %>%
  ungroup() %>%
  group_by(Deck) %>%
  summarise(Top_32_Finishes = n())

winner_summary <- as.data.frame(table(tournament_winners))
colnames(winner_summary) <- c("Deck", "Tournament_Wins")

final_report <- playrate_df %>%
  left_join(swiss_performance, by = c("Leader" = "Deck")) %>%
  left_join(top_32_finishers, by = c("Leader" = "Deck")) %>%
  left_join(winner_summary, by = c("Leader" = "Deck")) %>%
  mutate(across(where(is.numeric), ~replace_na(., 0))) %>%
  mutate(
    Short_Name = gsub(" ", "_", Leader),
    Total_Played = round(initial_probabilities * N_AGENTS * N_TOURNAMENTS),
    Top_32_Conversion_Rate = Top_32_Finishes / Total_Played,
    Tournament_Win_Rate = Tournament_Wins / N_TOURNAMENTS
  ) %>%
  
  select(Leader, Short_Name, Playrate, Swiss_Win_Rate, Top_32_Conversion_Rate, Tournament_Win_Rate)

# Display the final report table
knitr::kable(final_report %>% arrange(desc(Tournament_Win_Rate)),
             caption = "Final Leader Performance Report",
             digits = 4)

```

## **4. Visualizations**

The calculated metrics are visualized to facilitate interpretation. The following plots illustrate the primary findings of the simulation.

```{r}
# --- Define a reusable theme for the bar charts ---
bar_chart_theme <- theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 12),
    plot.title = element_text(face = "bold", size = 18),
    plot.subtitle = element_text(size = 12, color = "gray40"),
    plot.margin = margin(10, 10, 10, 10)
  )

# Plot 1: Overall Tournament Win Rate
plot1 <- ggplot(final_report, aes(x = reorder(Short_Name, -Tournament_Win_Rate), y = Tournament_Win_Rate * 100)) +
  geom_bar(stat = "identity", fill = "#4E79A7") +
  labs(title = "Overall Tournament Win Rate",
       subtitle = paste("Based on", N_TOURNAMENTS, "simulated events"),
       x = NULL, y = "Win Rate (%)") +
  bar_chart_theme

# Plot 2: Play Rate vs. Swiss Performance
plot2 <- ggplot(final_report, aes(x = Playrate, y = Swiss_Win_Rate * 100)) +
  geom_hline(yintercept = 50, linetype = "dashed", color = "red", alpha = 0.8) +
  geom_point(aes(color = Leader), size = 5, alpha = 0.8) +
  geom_text_repel(aes(label = Short_Name), size = 4, max.overlaps = Inf, box.padding = 0.5) +
  theme_minimal(base_size = 14) +
  labs(title = "Popularity vs. Performance",
       subtitle = "Swiss Round Win Rate vs. Initial Play Rate",
       x = "Initial Play Rate (%)", y = "Swiss Win Rate (%)") +
  theme(legend.position = "none",
        plot.title = element_text(face = "bold", size = 18),
        plot.subtitle = element_text(size = 12, color = "gray40"))

# Plot 3: Top 32 Conversion Rate
plot3 <- ggplot(final_report, aes(x = reorder(Short_Name, -Top_32_Conversion_Rate), y = Top_32_Conversion_Rate * 100)) +
  geom_bar(stat = "identity", fill = "#59A14F") +
  labs(title = "Top 32 Conversion Rate",
       subtitle = "Likelihood of making the playoff cut",
       x = "Leader", y = "Conversion Rate (%)") +
  bar_chart_theme

# --- Display and save each plot ---
print(plot1)
print(plot2)
print(plot3)

ggsave("tournament_win_rate.png", plot1, width = 11, height = 7, dpi = 150)
ggsave("popularity_vs_performance.png", plot2, width = 11, height = 7, dpi = 150)
ggsave("top32_conversion_rate.png", plot3, width = 11, height = 7, dpi = 150)
```
